import { mutation, query } from "./_generated/server";
import { v } from "convex/values";
import { generateKeypair, encryptSecretKey } from './walletKeypairs';

/**
 * Migration script to fix franchise wallets with invalid Solana addresses
 * This will regenerate real Solana keypairs for all existing franchise wallets
 */

/**
 * Check if a string is a valid Solana address AND has a secret key
 * Stricter validation to ensure it's a real, usable wallet
 */
function isValidSolanaAddress(address: string, hasSecretKey?: boolean): boolean {
  // Must have a secret key to be considered valid (generated by our system)
  if (!hasSecretKey) {
    console.log(`‚ùå Wallet ${address} missing secret key`);
    return false;
  }
  
  // Basic validation
  if (!address || address.length < 32 || address.length > 44) {
    return false;
  }
  
  // Check if it starts with mock prefixes
  if (address.startsWith('franchise_') || 
      address.startsWith('funding_pda_') || 
      address.includes('mock_') ||
      address.includes('_')) {
    return false;
  }
  
  // Solana addresses are base58 encoded and typically 32-44 chars
  // Valid base58 characters: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
  // Note: 0, O, I, l are NOT valid (to avoid confusion)
  const base58Regex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;
  if (!base58Regex.test(address)) {
    return false;
  }
  
  return true;
}

/**
 * Find all franchise wallets with invalid addresses
 */
export const findInvalidWallets = query({
  args: {},
  handler: async (ctx) => {
    const allWallets = await ctx.db.query("franchiseWallets").collect();
    
    const invalidWallets = allWallets.filter(wallet => {
      return !isValidSolanaAddress(wallet.walletAddress, !!wallet.walletSecretKey);
    });
    
    return {
      total: allWallets.length,
      invalid: invalidWallets.length,
      invalidWallets: invalidWallets.map(w => ({
        _id: w._id,
        franchiseId: w.franchiseId,
        walletName: w.walletName,
        currentAddress: w.walletAddress,
        hasSecretKey: !!w.walletSecretKey,
      })),
    };
  },
});

/**
 * Migrate a single franchise wallet to use a real Solana address
 */
export const migrateWallet = mutation({
  args: {
    walletId: v.id("franchiseWallets"),
  },
  handler: async (ctx, args) => {
    const wallet = await ctx.db.get(args.walletId);
    if (!wallet) {
      throw new Error("Wallet not found");
    }
    
    // Check if already valid
    if (isValidSolanaAddress(wallet.walletAddress, !!wallet.walletSecretKey)) {
      return {
        success: true,
        message: "Wallet already has valid address and secret key",
        address: wallet.walletAddress,
      };
    }
    
    // Generate new real keypair
    const newKeypair = generateKeypair();
    
    console.log(`üîÑ Migrating wallet ${wallet.walletName}`);
    console.log(`   Old: ${wallet.walletAddress}`);
    console.log(`   New: ${newKeypair.publicKey}`);
    
    // Update wallet with real address and secret key
    await ctx.db.patch(args.walletId, {
      walletAddress: newKeypair.publicKey,
      walletSecretKey: encryptSecretKey(newKeypair.secretKey),
      updatedAt: Date.now(),
    });
    
    return {
      success: true,
      message: "Wallet migrated successfully",
      oldAddress: wallet.walletAddress,
      newAddress: newKeypair.publicKey,
      explorerUrl: `https://explorer.solana.com/address/${newKeypair.publicKey}?cluster=devnet`,
    };
  },
});

/**
 * Migrate all invalid franchise wallets at once
 */
export const migrateAllInvalidWallets = mutation({
  args: {},
  handler: async (ctx) => {
    const allWallets = await ctx.db.query("franchiseWallets").collect();
    
    const invalidWallets = allWallets.filter(wallet => {
      return !isValidSolanaAddress(wallet.walletAddress, !!wallet.walletSecretKey);
    });
    
    if (invalidWallets.length === 0) {
      return {
        success: true,
        message: "No invalid wallets found",
        migrated: 0,
      };
    }
    
    // Generate new keypairs for all invalid wallets
    const results = [];
    
    for (const wallet of invalidWallets) {
      const newKeypair = generateKeypair();
      
      console.log(`üîÑ Migrating: ${wallet.walletName}`);
      console.log(`   ${wallet.walletAddress} ‚Üí ${newKeypair.publicKey}`);
      
      await ctx.db.patch(wallet._id, {
        walletAddress: newKeypair.publicKey,
        walletSecretKey: encryptSecretKey(newKeypair.secretKey),
        updatedAt: Date.now(),
      });
      
      results.push({
        walletName: wallet.walletName,
        oldAddress: wallet.walletAddress,
        newAddress: newKeypair.publicKey,
      });
    }
    
    return {
      success: true,
      message: `Successfully migrated ${invalidWallets.length} wallets`,
      migrated: invalidWallets.length,
      results,
    };
  },
});

/**
 * Verify all wallets have valid addresses
 */
export const verifyAllWallets = query({
  args: {},
  handler: async (ctx) => {
    const allWallets = await ctx.db.query("franchiseWallets").collect();
    
    const validation = allWallets.map(wallet => ({
      _id: wallet._id,
      walletName: wallet.walletName,
      address: wallet.walletAddress,
      isValid: isValidSolanaAddress(wallet.walletAddress, !!wallet.walletSecretKey),
      hasSecretKey: !!wallet.walletSecretKey,
      explorerUrl: isValidSolanaAddress(wallet.walletAddress, !!wallet.walletSecretKey) 
        ? `https://explorer.solana.com/address/${wallet.walletAddress}?cluster=devnet`
        : null,
    }));
    
    const validCount = validation.filter(v => v.isValid).length;
    const invalidCount = validation.filter(v => !v.isValid).length;
    
    return {
      total: allWallets.length,
      valid: validCount,
      invalid: invalidCount,
      wallets: validation,
    };
  },
});

